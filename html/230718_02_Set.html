<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>** Collection Set **</title>
    <script>
      // ** Array
      // => 문자열의 중복을 허용하지 않는 배열 정의하기
      // (조원들의 이름을 중복을 허용하지 않고 배열에 담기)
      //    -> 1) 배열정의
      //    -> 2) 중복확인기능(함수)
      //    -> 3) 배열에 자료 담기
      // 1)
      let names = [];
      //   let names = new Array();
      // 2)
      // => 매게변수 text로 전달된 값을 배열 names의 요소들과 비교해서
      //    동일값이 없으면 return true, 있으면 return false
      const unique = (text) => {
        for (let name of names) {
          if (text == name) return false;
        } //for
        return true;
      };
      // 3) str을 names에 담기(중복없이)
      let str = [
        "배정현",
        "김소라",
        "은희상",
        "김소라",
        "최승호",
        "은희상",
        "김소라",
        "최승호",
      ];
      for (let name of str) {
        // 중복검사 후 담기
        if (unique(name) == true) names.push(name);
      }
      // 4) 출력 확인
      for (let name of names) {
        console.log(`name => ${name}`);
      }
      console.log(`names.length => ${names.length}`);

      // ** Set과 비교
      // => str -> mySet에 담기
      // => Set의 메소드 : add, delete, has, size
      let mySet = new Set();

      for (let name of str) {
        mySet.add(name);
      }

      mySet.delete("은희상");
      mySet.delete("은희상"); // 없는 값을 delete 하는 경우, error 없이 통과

      for (let name of mySet) {
        console.log(`name => ${name}`);
      }
      console.log(
        `mySet.has => 은희상 = ${mySet.has("은희상")},
        최승호 = ${mySet.has("최승호")}`
      );
      console.log(`mySet.size => ${mySet.size}`);
      console.log(`mySet => ${mySet}`);

      // => Set 생성과 동시에 초기화
      let mySet2 = new Set(str);
      for (name of mySet2) {
        console.log(`** Name2 = ${name}`);
      }

      // ** Set 메소드 체이닝
      // => 처리 후 Set Type을 return 하는 메소드는 계속 .으로 연결해서 사용 가능
      // 단, delete 메소드는 boolean형을 return하므로 불가, 마지막엔 가능
      mySet2.add("설수현").add("신혜진").add("연제승").delete("설수현");
      for (name of mySet2) {
        console.log(`** Name3 = ${name}`);
      }

      // ** forEach(CallBack함수) : 요소를 순회
      // => 이때 매개변수로 사용되는 CallBack함수 는 3개의 인수를 전달받음
      //    (현재 요소값, 현재 요소값, 현재 순회중인 set객체 자체)
      // => 배열의 forEach 메서드 Array.prototype.forEach 의 CallBack함수 인수 3개는
      //    (현재 요소값, 현재 인덱스, 현재 순회중인 배열객체 자체)
      // => Map의 forEach 메서드 Map.prototype.forEach 의 CallBack함수 인수 3개는
      //    (현재 value, 현재 key, 현재 순회중인 map객체 자체)
      mySet2.forEach((v1, v2) => {
        console.log(`** forEach(함수) = ${v1}, ${v2}`);
      });
    </script>
  </head>
  <body>
    <pre>
    <h3>** 새로 추가된 컬렉션(collections) Set **</h3>
    => Set은 중복을 허용하지 않는 데이터(value) 들의 집합.
    => Set은 수정 가능하며, 프로그램이 실행되는 동안 값의 추가나 삭제 가능함.
      ( delete 성공시 true 를 반환하고 실패시 false 를 반환 )
    
    ** Set과 Array 의 차이점 **
    => 값이 중복되지 않습니다 ( 중복값은 저장하지 않음 )
      const mySet = new Set("abcd");
      mySet.size; // 4
      mySet.add("a");
      mySet.size; // 4
    
    => 데이터 확인이 편리하고 빠름.
      const mySet = new Set("abcd");
      const myArray = [..."abcd"];
        
      myArray.indexOf("a") !== -1 // true slow
      mySet.has("a")              // true fast   
      
    => Set은 인덱스 값으로 데이터 조회는 불가능
      myArray[0]; // "a"
      mySet[0];   // undefined
    </pre>
  </body>
</html>
